<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clubhouse Tabletop Collection</title>
    <style>
        /* --- CORE VISUALS & RESET --- */
        :root {
            --bg-wood: #3e2723;
            --bg-felt: #2e7d32;
            --card-bg: #fff;
            --text-primary: #1a1a1a;
            --accent: #ffb74d;
            --shadow: 0 10px 20px rgba(0,0,0,0.4);
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }
        
        body {
            font-family: var(--font-main);
            background-color: var(--bg-wood);
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M20 20h20v20H20V20zM0 0h20v20H0V0z' fill='%234e342e' fill-opacity='0.4' fill-rule='evenodd'/%3E%3C/svg%3E");
            height: 100vh;
            overflow: hidden;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- THE HUB (MENU) --- */
        #game-hub {
            width: 90%;
            height: 90%;
            background: rgba(0,0,0,0.2);
            border-radius: 20px;
            padding: 40px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(5px);
            transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.6s;
        }

        .hub-header {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            overflow-y: auto;
            padding: 10px;
        }

        /* Scrollbar styling */
        .game-grid::-webkit-scrollbar { width: 8px; }
        .game-grid::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 4px; }

        .game-card {
            background: var(--card-bg);
            color: var(--text-primary);
            border-radius: 12px;
            height: 180px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
        }

        .game-card:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 12px 20px rgba(0,0,0,0.4);
            z-index: 10;
        }

        .game-card.disabled {
            filter: grayscale(100%);
            opacity: 0.6;
            cursor: not-allowed;
        }

        .game-icon { font-size: 3rem; margin-bottom: 10px; }
        .game-title { font-weight: bold; font-size: 1.1rem; }
        .game-status { font-size: 0.8rem; color: #666; margin-top: 5px; }

        /* --- ACTIVE GAME CONTAINER --- */
        #active-game-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg-felt);
            transform: translateY(100%); /* Hidden by default */
            transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            flex-direction: column;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.5);
        }

        #active-game-container.visible { transform: translateY(0); }

        .game-navbar {
            padding: 15px 30px;
            background: rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            background: var(--accent);
            color: #3e2723;
            font-weight: bold;
            border-radius: 20px;
            cursor: pointer;
            transition: background 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .btn:hover { background: #ffcc80; }
        .btn-secondary { background: rgba(255,255,255,0.2); color: white; }
        
        .game-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            position: relative;
        }

        .status-display {
            font-size: 1.5rem;
            margin-bottom: 20px;
            background: rgba(0,0,0,0.4);
            padding: 10px 30px;
            border-radius: 30px;
            min-height: 50px;
            display: flex;
            align-items: center;
        }

        /* --- SPECIFIC GAME STYLES --- */

        /* Connect 4 */
        .c4-board {
            background-color: #0055ff;
            padding: 15px;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(7, 60px);
            grid-gap: 10px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .c4-cell {
            width: 60px; height: 60px;
            background-color: var(--bg-felt); /* See-through effect */
            border-radius: 50%;
            cursor: pointer;
            position: relative;
            box-shadow: inset 0 5px 10px rgba(0,0,0,0.5);
        }
        .c4-cell.red { background-color: #e53935; box-shadow: inset -2px -2px 10px rgba(0,0,0,0.3); }
        .c4-cell.yellow { background-color: #fdd835; box-shadow: inset -2px -2px 10px rgba(0,0,0,0.3); }
        
        /* Tic Tac Toe */
        .ttt-board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-gap: 10px;
        }
        .ttt-cell {
            width: 100px; height: 100px;
            background: rgba(255,255,255,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 10px;
            transition: background 0.2s;
        }
        .ttt-cell:hover { background: rgba(255,255,255,0.2); }
        .ttt-cell.x { color: #f48fb1; }
        .ttt-cell.o { color: #81d4fa; }

    </style>
</head>
<body>

    <div id="game-hub">
        <div class="hub-header">Clubhouse Collection</div>
        <div class="game-grid" id="game-grid">
            </div>
    </div>

    <div id="active-game-container">
        <div class="game-navbar">
            <button class="btn btn-secondary" onclick="app.returnToHub()">‚Üê Back to Hub</button>
            <h2 id="current-game-title">Game Title</h2>
            <button class="btn" onclick="app.resetCurrentGame()">Reset Game</button>
        </div>
        <div class="game-area">
            <div class="status-display" id="game-status">Player's Turn</div>
            <div id="game-board-container"></div>
        </div>
    </div>

    <script>
        /**
         * CLUBHOUSE ARCHITECT ENGINE
         * Complex Modular System for Board Games
         */

        // --- 1. CORE SYSTEM ---
        class GameEngine {
            constructor() {
                this.games = [
                    { id: 'c4', name: 'Connect Four', icon: 'üî¥', active: true, class: ConnectFour },
                    { id: 'ttt', name: 'Tic Tac Toe', icon: '‚ùå', active: true, class: TicTacToe },
                    { id: 'chess', name: 'Chess', icon: '‚ôüÔ∏è', active: false },
                    { id: 'checkers', name: 'Checkers', icon: '‚ö™', active: false },
                    { id: 'othello', name: 'Reversi', icon: '‚ö´', active: false },
                    { id: 'mancala', name: 'Mancala', icon: 'üíé', active: false },
                    { id: 'dots', name: 'Dots & Boxes', icon: '‚¨õ', active: false },
                    { id: 'battleship', name: 'Sea Battle', icon: 'üö¢', active: false },
                    { id: 'memory', name: 'Memory', icon: 'üÉè', active: false },
                    { id: 'backgammon', name: 'Backgammon', icon: 'üé≤', active: false },
                    { id: 'ludo', name: 'Ludo', icon: 'üé≤', active: false },
                    { id: 'gomoku', name: 'Gomoku', icon: '‚ö™', active: false }
                ];
                this.currentGame = null;
                this.initHub();
            }

            initHub() {
                const grid = document.getElementById('game-grid');
                this.games.forEach(game => {
                    const card = document.createElement('div');
                    card.className = `game-card ${game.active ? '' : 'disabled'}`;
                    card.innerHTML = `
                        <div class="game-icon">${game.icon}</div>
                        <div class="game-title">${game.name}</div>
                        <div class="game-status">${game.active ? 'Play vs AI' : 'Coming Soon'}</div>
                    `;
                    card.onclick = () => {
                        if (game.active) this.launchGame(game);
                    };
                    grid.appendChild(card);
                });
            }

            launchGame(gameMeta) {
                document.getElementById('game-hub').style.transform = 'scale(0.9) translateY(-20px)';
                document.getElementById('game-hub').style.opacity = '0';
                
                setTimeout(() => {
                    document.getElementById('game-hub').style.display = 'none';
                    const container = document.getElementById('active-game-container');
                    container.classList.add('visible');
                    document.getElementById('current-game-title').innerText = gameMeta.name;
                    
                    // Instantiate the game class
                    this.currentGame = new gameMeta.class(
                        document.getElementById('game-board-container'),
                        document.getElementById('game-status')
                    );
                }, 300);
            }

            returnToHub() {
                const container = document.getElementById('active-game-container');
                container.classList.remove('visible');
                
                setTimeout(() => {
                    document.getElementById('game-hub').style.display = 'flex';
                    // Trigger reflow
                    void document.getElementById('game-hub').offsetWidth;
                    document.getElementById('game-hub').style.transform = 'none';
                    document.getElementById('game-hub').style.opacity = '1';
                    this.currentGame = null;
                    document.getElementById('game-board-container').innerHTML = '';
                }, 400);
            }

            resetCurrentGame() {
                if (this.currentGame) this.currentGame.init();
            }
        }

        // --- 2. GAME BASE CLASS ---
        class BoardGame {
            constructor(container, statusElement) {
                this.container = container;
                this.statusEl = statusElement;
                this.isPlayerTurn = true;
                this.gameOver = false;
                this.init();
            }

            updateStatus(msg) {
                this.statusEl.innerText = msg;
            }

            aiDelay(callback) {
                setTimeout(callback, 700); // Simulate thinking time
            }
        }

        // --- 3. GAME IMPLEMENTATION: TIC TAC TOE ---
        class TicTacToe extends BoardGame {
            init() {
                this.board = Array(9).fill(null);
                this.isPlayerTurn = true; // Player is X
                this.gameOver = false;
                this.render();
                this.updateStatus("Your Turn (X)");
            }

            render() {
                this.container.innerHTML = '<div class="ttt-board"></div>';
                const boardEl = this.container.querySelector('.ttt-board');
                
                this.board.forEach((cell, idx) => {
                    const cellEl = document.createElement('div');
                    cellEl.className = `ttt-cell ${cell ? cell.toLowerCase() : ''}`;
                    cellEl.innerText = cell || '';
                    cellEl.onclick = () => this.handleMove(idx);
                    boardEl.appendChild(cellEl);
                });
            }

            handleMove(idx) {
                if (this.board[idx] || !this.isPlayerTurn || this.gameOver) return;
                
                this.board[idx] = 'X';
                this.render();
                
                if (this.checkWin('X')) {
                    this.gameOver = true;
                    this.updateStatus("You Win!");
                    return;
                }
                if (!this.board.includes(null)) {
                    this.gameOver = true;
                    this.updateStatus("Draw!");
                    return;
                }

                this.isPlayerTurn = false;
                this.updateStatus("AI Thinking...");
                this.aiDelay(() => this.makeAIMove());
            }

            makeAIMove() {
                if (this.gameOver) return;
                // Minimax for perfect play
                let bestScore = -Infinity;
                let move;
                for (let i = 0; i < 9; i++) {
                    if (this.board[i] === null) {
                        this.board[i] = 'O';
                        let score = this.minimax(this.board, 0, false);
                        this.board[i] = null;
                        if (score > bestScore) {
                            bestScore = score;
                            move = i;
                        }
                    }
                }
                this.board[move] = 'O';
                this.render();
                
                if (this.checkWin('O')) {
                    this.gameOver = true;
                    this.updateStatus("AI Wins!");
                } else if (!this.board.includes(null)) {
                    this.gameOver = true;
                    this.updateStatus("Draw!");
                } else {
                    this.isPlayerTurn = true;
                    this.updateStatus("Your Turn (X)");
                }
            }

            checkWin(player) {
                const wins = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
                return wins.some(c => this.board[c[0]] === player && this.board[c[1]] === player && this.board[c[2]] === player);
            }

            minimax(board, depth, isMaximizing) {
                if (this.checkWin('O')) return 10 - depth;
                if (this.checkWin('X')) return depth - 10;
                if (!board.includes(null)) return 0;

                if (isMaximizing) {
                    let bestScore = -Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (board[i] === null) {
                            board[i] = 'O';
                            let score = this.minimax(board, depth + 1, false);
                            board[i] = null;
                            bestScore = Math.max(score, bestScore);
                        }
                    }
                    return bestScore;
                } else {
                    let bestScore = Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (board[i] === null) {
                            board[i] = 'X';
                            let score = this.minimax(board, depth + 1, true);
                            board[i] = null;
                            bestScore = Math.min(score, bestScore);
                        }
                    }
                    return bestScore;
                }
            }
        }

        // --- 4. GAME IMPLEMENTATION: CONNECT FOUR ---
        class ConnectFour extends BoardGame {
            init() {
                this.rows = 6;
                this.cols = 7;
                this.board = Array(this.rows).fill().map(() => Array(this.cols).fill(null));
                this.isPlayerTurn = true;
                this.gameOver = false;
                this.render();
                this.updateStatus("Your Turn (Red)");
            }

            render() {
                this.container.innerHTML = '<div class="c4-board"></div>';
                const boardEl = this.container.querySelector('.c4-board');
                
                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = `c4-cell ${this.board[r][c] || ''}`;
                        cell.onclick = () => this.handleMove(c);
                        boardEl.appendChild(cell);
                    }
                }
            }

            handleMove(col) {
                if (!this.isPlayerTurn || this.gameOver) return;
                
                // Find lowest empty row in col
                let row = -1;
                for (let r = this.rows - 1; r >= 0; r--) {
                    if (!this.board[r][col]) {
                        row = r;
                        break;
                    }
                }
                
                if (row === -1) return; // Column full

                this.dropPiece(row, col, 'red');
                
                if (this.checkWin(row, col, 'red')) {
                    this.gameOver = true;
                    this.updateStatus("Red Wins!");
                    return;
                }

                this.isPlayerTurn = false;
                this.updateStatus("AI Thinking...");
                this.aiDelay(() => this.makeAIMove());
            }

            dropPiece(r, c, color) {
                this.board[r][c] = color;
                this.render();
            }

            makeAIMove() {
                if (this.gameOver) return;

                // Simple AI: Try to win, block opponent, or random
                // 1. Check for winning move
                let move = this.findBestMove('yellow') || this.findBestMove('red') || this.getRandomMove();

                if (move !== null) {
                    let r = -1;
                    for (let i = this.rows - 1; i >= 0; i--) {
                        if (!this.board[i][move]) { r = i; break; }
                    }
                    this.dropPiece(r, move, 'yellow');
                    if (this.checkWin(r, move, 'yellow')) {
                        this.gameOver = true;
                        this.updateStatus("AI (Yellow) Wins!");
                    } else {
                        this.isPlayerTurn = true;
                        this.updateStatus("Your Turn (Red)");
                    }
                }
            }

            findBestMove(color) {
                // Simulate dropping piece in each column to see if it wins/blocks
                for (let c = 0; c < this.cols; c++) {
                    if (this.board[0][c]) continue; // Column full
                    let r = -1;
                    for (let i = this.rows - 1; i >= 0; i--) {
                        if (!this.board[i][c]) { r = i; break; }
                    }
                    
                    this.board[r][c] = color;
                    let win = this.checkWin(r, c, color);
                    this.board[r][c] = null; // Backtrack
                    if (win) return c;
                }
                return null;
            }

            getRandomMove() {
                let validCols = [];
                for(let c=0; c<this.cols; c++) if(!this.board[0][c]) validCols.push(c);
                return validCols[Math.floor(Math.random() * validCols.length)];
            }

            checkWin(r, c, color) {
                const directions = [
                    [0, 1], // horizontal
                    [1, 0], // vertical
                    [1, 1], // diagonal right
                    [1, -1] // diagonal left
                ];

                return directions.some(([dr, dc]) => {
                    let count = 1;
                    // Positive direction
                    for (let i = 1; i < 4; i++) {
                        const nr = r + dr * i, nc = c + dc * i;
                        if (nr >= 0 && nr < this.rows && nc >= 0 && nc < this.cols && this.board[nr][nc] === color) count++;
                        else break;
                    }
                    // Negative direction
                    for (let i = 1; i < 4; i++) {
                        const nr = r - dr * i, nc = c - dc * i;
                        if (nr >= 0 && nr < this.rows && nc >= 0 && nc < this.cols && this.board[nr][nc] === color) count++;
                        else break;
                    }
                    return count >= 4;
                });
            }
        }

        // --- INITIALIZATION ---
        const app = new GameEngine();

    </script>
</body>
</html>
