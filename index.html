<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clubhouse Deluxe v10</title>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;600;800&family=Cinzel+Decorative:wght@700&family=Chivo+Mono:wght@500&display=swap" rel="stylesheet">
    <style>
        /* --- VISUAL CORE --- */
        :root {
            --bg-wood: #3e2723;
            --bg-felt: #1b5e20;
            --accent: #ffb300;
            --text-light: #eceff1;
            --shadow-deep: 0 10px 30px rgba(0,0,0,0.8);
        }
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }
        body {
            font-family: 'Rubik', sans-serif;
            background: radial-gradient(circle, #4e342e, #212121);
            color: var(--text-light);
            height: 100vh; overflow: hidden;
            display: flex;
        }

        /* --- MENUS --- */
        #hub {
            position: absolute; inset: 0; z-index: 100;
            background: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M20 20h20v20H20V20zM0 0h20v20H0V0z' fill='%232d1b18' fill-opacity='0.4' fill-rule='evenodd'/%3E%3C/svg%3E"), linear-gradient(#5d4037, #3e2723);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: transform 0.5s ease-in-out;
        }
        #hub.hidden { transform: translateY(-100%); }
        .grid { 
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 30px; width: 80%; max-width: 1200px; padding: 20px; 
        }
        .card {
            background: #fff; color: #333; height: 220px; border-radius: 15px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; box-shadow: 0 10px 0 #bdbdbd, var(--shadow-deep);
            transition: transform 0.2s; border: 4px solid #fff;
        }
        .card:hover { transform: translateY(-5px); box-shadow: 0 15px 0 #bdbdbd, var(--shadow-deep); }
        .card.disabled { filter: grayscale(1); opacity: 0.5; pointer-events: none; }
        .icon { font-size: 4rem; margin-bottom: 10px; }
        .title { font-weight: 800; font-size: 1.5rem; text-transform: uppercase; }

        #modal {
            position: absolute; inset: 0; background: rgba(0,0,0,0.85); z-index: 200;
            display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: 0.3s;
        }
        #modal.active { opacity: 1; pointer-events: all; }
        .modal-box { 
            background: #fff; color: #333; padding: 40px; border-radius: 20px; text-align: center; 
            box-shadow: 0 0 50px rgba(255,179,0,0.5); border: 4px solid var(--accent);
        }
        .btn {
            padding: 15px 30px; border: none; background: #333; color: #fff; font-weight: bold; font-size: 1.1rem;
            border-radius: 8px; cursor: pointer; margin: 10px; transition: 0.2s;
        }
        .btn:hover { background: var(--accent); color: #000; transform: scale(1.05); }

        /* --- GAME CONTAINER (FULL SCREEN) --- */
        #game-screen {
            display: flex; width: 100%; height: 100%; opacity: 0; transition: opacity 0.5s 0.5s;
        }
        #game-screen.visible { opacity: 1; }
        
        .main-stage {
            flex: 1; position: relative; background: var(--bg-felt);
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAIklEQVQIW2NkQAKrVq36zwjjgzjwquNvLM0YHEEMdDCkAQBmWxL/m57O5AAAAABJRU5ErkJggg==');
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        
        .sidebar {
            width: 350px; background: #2d1b18; border-left: 5px solid #1a100e;
            display: flex; flex-direction: column; padding: 20px; box-shadow: -10px 0 30px rgba(0,0,0,0.5);
            z-index: 50;
        }

        .nav-bar {
            position: absolute; top: 0; left: 0; width: 100%; padding: 15px;
            display: flex; justify-content: space-between; pointer-events: none;
        }
        .nav-btn { pointer-events: auto; background: rgba(0,0,0,0.5); color: #fff; border: 1px solid #fff; padding: 8px 15px; border-radius: 20px; cursor: pointer; }
        .nav-btn:hover { background: #fff; color: #000; }

        /* --- YAHTZEE SPECIFIC --- */
        .yz-hold-zone {
            width: 100%; height: 120px; display: flex; justify-content: center; gap: 20px;
            margin-bottom: 20px; padding: 10px;
            background: rgba(0,0,0,0.2); border-bottom: 2px solid rgba(255,255,255,0.1);
        }
        .hold-slot {
            width: 90px; height: 90px; background: rgba(0,0,0,0.3); border-radius: 10px;
            border: 2px dashed rgba(255,255,255,0.2); 
            display: flex; align-items: center; justify-content: center;
            box-shadow: inset 0 5px 10px rgba(0,0,0,0.5);
            transition: border-color 0.2s;
        }
        .hold-slot.active { border-color: var(--accent); background: rgba(255,179,0,0.1); }

        .yz-roll-zone {
            flex: 1; width: 100%; position: relative; perspective: 1000px;
            display: flex; justify-content: center; align-items: center;
        }
        
        /* 3D Dice */
        .die {
            width: 80px; height: 80px; position: absolute; transform-style: preserve-3d;
            cursor: pointer; transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275), top 0.4s, left 0.4s;
        }
        .die.rolling { animation: shake 0.4s infinite linear; }
        .die-face {
            position: absolute; width: 100%; height: 100%; background: radial-gradient(#fff, #eee);
            border-radius: 12px; box-shadow: inset 0 0 5px rgba(0,0,0,0.2); border: 1px solid #ccc;
            display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; padding: 6px;
        }
        .pip { background: #222; border-radius: 50%; box-shadow: inset 1px 1px 2px #000; align-self: center; justify-self: center; width: 14px; height: 14px; }
        
        /* Transforms */
        .df1 { transform: translateZ(40px); }
        .df6 { transform: rotateY(180deg) translateZ(40px); }
        .df2 { transform: rotateX(-90deg) translateZ(40px); }
        .df5 { transform: rotateX(90deg) translateZ(40px); }
        .df3 { transform: rotateY(90deg) translateZ(40px); }
        .df4 { transform: rotateY(-90deg) translateZ(40px); }

        /* Pip placement logic */
        .df1 .pip:nth-child(1) { grid-area: 2/2; }
        .df2 .pip:nth-child(1) { grid-area: 1/1; } .df2 .pip:nth-child(2) { grid-area: 3/3; }
        .df3 .pip:nth-child(1) { grid-area: 1/1; } .df3 .pip:nth-child(2) { grid-area: 2/2; } .df3 .pip:nth-child(3) { grid-area: 3/3; }
        .df4 .pip:nth-child(1) { grid-area: 1/1; } .df4 .pip:nth-child(2) { grid-area: 1/3; } .df4 .pip:nth-child(3) { grid-area: 3/1; } .df4 .pip:nth-child(4) { grid-area: 3/3; }
        .df5 .pip:nth-child(1) { grid-area: 1/1; } .df5 .pip:nth-child(2) { grid-area: 1/3; } .df5 .pip:nth-child(3) { grid-area: 2/2; } .df5 .pip:nth-child(4) { grid-area: 3/1; } .df5 .pip:nth-child(5) { grid-area: 3/3; }
        .df6 .pip:nth-child(1) { grid-area: 1/1; } .df6 .pip:nth-child(2) { grid-area: 1/3; } .df6 .pip:nth-child(3) { grid-area: 2/1; } .df6 .pip:nth-child(4) { grid-area: 2/3; } .df6 .pip:nth-child(5) { grid-area: 3/1; } .df6 .pip:nth-child(6) { grid-area: 3/3; }

        @keyframes shake { 0% { transform: rotate3d(1,1,1,0deg); } 100% { transform: rotate3d(1,2,0,360deg); } }

        /* Scorecard in Sidebar */
        .score-card { background: #fff8e1; color: #333; font-family: 'Chivo Mono', monospace; padding: 10px; border-radius: 8px; flex: 1; overflow-y: auto; }
        .sc-row { display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px solid #ccc; cursor: pointer; }
        .sc-row:hover:not(.locked) { background: #ffe082; }
        .sc-row.locked { color: #999; cursor: default; }
        .sc-cat { font-weight: bold; font-size: 0.9rem; }
        .sc-val { font-weight: bold; }
        .sc-header { display: flex; background: #333; color: #fff; padding: 5px; font-weight: bold; }
        .sc-col { flex: 1; text-align: center; } .sc-col.wide { flex: 2; text-align: left; }

        /* --- CONNECT 4 & CHESS & CHECKERS Styles --- */
        .c4-board { display: grid; grid-template-columns: repeat(7, 80px); gap: 10px; padding: 15px; background: #01579b; border-radius: 10px; box-shadow: var(--shadow-deep); }
        .c4-slot { width: 80px; height: 80px; background: rgba(0,0,0,0.3); border-radius: 50%; cursor: pointer; position: relative; overflow: hidden; box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5); }
        .c4-piece { width: 100%; height: 100%; border-radius: 50%; position: absolute; top: -100%; transition: top 0.5s cubic-bezier(0.5, 0, 0.5, 1); box-shadow: inset -2px -2px 5px rgba(0,0,0,0.5); }
        .c4-piece.red { background: #d32f2f; } .c4-piece.yel { background: #fbc02d; }
        .c4-piece.dropped { top: 0; }

        .chess-board, .chk-board { width: 640px; height: 640px; display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); border: 20px solid #4e342e; box-shadow: var(--shadow-deep); }
        .cell { display: flex; align-items: center; justify-content: center; position: relative; }
        .cell.light { background: #d7ccc8; } .cell.dark { background: #8d6e63; }
        .cell.highlight::after { content:''; position: absolute; width: 20px; height: 20px; background: rgba(0,255,0,0.5); border-radius: 50%; }
        .chess-p { font-size: 50px; cursor: pointer; filter: drop-shadow(2px 4px 2px rgba(0,0,0,0.5)); transition: transform 0.2s; }
        .chess-p:hover { transform: translateY(-5px); }
        .chk-p { width: 60px; height: 60px; border-radius: 50%; box-shadow: 0 5px 5px rgba(0,0,0,0.5); cursor: pointer; border: 4px solid rgba(255,255,255,0.1); }
        .chk-p.r { background: #b71c1c; } .chk-p.b { background: #212121; }
        .chk-p.king { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='gold'%3E%3Cpath d='M12 2l3 5h6l-3 5 2 8H4l2-8-3-5h6z'/%3E%3C/svg%3E"); background-size: 30px; background-repeat: no-repeat; background-position: center; }

        .ttt-board { display: grid; grid-template-columns: repeat(3, 150px); gap: 15px; background: #8d6e63; padding: 20px; border-radius: 10px; }
        .ttt-cell { width: 150px; height: 150px; background: #3e2723; display: flex; align-items: center; justify-content: center; font-size: 6rem; cursor: pointer; box-shadow: inset 0 0 10px #000; }
        .x { color: #e57373; } .o { color: #64b5f6; }

        /* --- CONTROLS IN SIDEBAR --- */
        .status-box { background: #212121; color: var(--accent); padding: 20px; text-align: center; font-size: 1.5rem; font-weight: bold; border-bottom: 1px solid #444; border-radius: 8px; margin-bottom: 20px; }
        .control-area { margin-top: auto; display: flex; flex-direction: column; gap: 10px; }

    </style>
</head>
<body>

    <div id="modal">
        <div class="modal-box">
            <h2 class="title" style="margin-bottom:20px; color:#333;">Select Mode</h2>
            <button class="btn" onclick="gameApp.start(true)">VS Computer</button>
            <button class="btn" onclick="gameApp.start(false)">2 Players</button>
        </div>
    </div>

    <div id="hub">
        <h1 class="title" style="font-size: 4rem; color: var(--accent); margin-bottom: 40px; text-shadow: 0 5px 10px rgba(0,0,0,0.5);">Clubhouse Deluxe</h1>
        <div class="grid" id="game-grid"></div>
    </div>

    <div id="game-screen">
        <div class="main-stage" id="stage">
            <div class="nav-bar">
                <button class="nav-btn" onclick="gameApp.exit()">Exit to Hub</button>
                <div style="font-weight:bold; font-size:1.2rem; text-shadow:0 2px 4px rgba(0,0,0,0.8)" id="game-title-display">Game</div>
            </div>
            <div id="board-container"></div>
        </div>

        <div class="sidebar">
            <div class="status-box" id="status">Ready</div>
            <div id="side-content" style="flex:1; display:flex; flex-direction:column; overflow:hidden;"></div>
            <div class="control-area" id="controls"></div>
        </div>
    </div>

    <script>
        /* --- CORE SYSTEM --- */
        const gameApp = {
            activeGame: null,
            currentGameId: null,
            isAI: false,
            games: [
                {id:'yz', n:'Yahtzee', i:'ðŸŽ²'},
                {id:'c4', n:'Connect 4', i:'ðŸ”´'},
                {id:'ch', n:'Chess', i:'â™Ÿï¸'},
                {id:'chk', n:'Checkers', i:'ðŸ'},
                {id:'ttt', n:'Tic Tac Toe', i:'âŒ'}
            ],
            
            init() {
                const g = document.getElementById('game-grid');
                this.games.forEach(gMeta => {
                    const c = document.createElement('div');
                    c.className = 'card';
                    c.innerHTML = `<div class="icon">${gMeta.i}</div><div class="title">${gMeta.n}</div>`;
                    c.onclick = () => this.prompt(gMeta.id);
                    g.appendChild(c);
                });
            },

            prompt(id) {
                this.currentGameId = id;
                document.getElementById('modal').classList.add('active');
            },

            start(isAI) {
                this.isAI = isAI;
                document.getElementById('modal').classList.remove('active');
                document.getElementById('hub').classList.add('hidden');
                document.getElementById('game-screen').classList.add('visible');
                
                const meta = this.games.find(x=>x.id===this.currentGameId);
                document.getElementById('game-title-display').innerText = meta.n;
                
                // Clear containers
                const board = document.getElementById('board-container');
                const side = document.getElementById('side-content');
                const ctrl = document.getElementById('controls');
                board.innerHTML = ''; side.innerHTML = ''; ctrl.innerHTML = '';

                // Instantiate
                if(this.currentGameId === 'yz') this.activeGame = new Yahtzee(board, side, ctrl, isAI);
                if(this.currentGameId === 'c4') this.activeGame = new Connect4(board, side, ctrl, isAI);
                if(this.currentGameId === 'ch') this.activeGame = new Chess(board, side, ctrl, isAI);
                if(this.currentGameId === 'chk') this.activeGame = new Checkers(board, side, ctrl, isAI);
                if(this.currentGameId === 'ttt') this.activeGame = new TTT(board, side, ctrl, isAI);
            },

            exit() {
                document.getElementById('game-screen').classList.remove('visible');
                document.getElementById('hub').classList.remove('hidden');
                this.activeGame = null;
            },

            setStatus(msg) { document.getElementById('status').innerText = msg; }
        };

        /* --- YAHTZEE ENGINE --- */
        class Yahtzee {
            constructor(boardEl, sideEl, ctrlEl, ai) {
                this.dice = [1,1,1,1,1];
                this.held = [false,false,false,false,false]; // true = in slot, false = in tray
                this.turn = 1; 
                this.rolls = 3;
                this.ai = ai;
                this.scores = { 1: {}, 2: {} }; // Maps category index to score
                this.cats = ["Ones","Twos","Threes","Fours","Fives","Sixes","3 of Kind","4 of Kind","Full House","Sm. Str","Lg. Str","Yahtzee","Chance"];
                this.els = { board: boardEl, side: sideEl, ctrl: ctrlEl };
                
                this.renderLayout();
                this.updateStatus();
            }

            renderLayout() {
                // Board: Hold Slots + Roll Tray
                this.els.board.innerHTML = `
                    <div style="width:100%; height:100%; display:flex; flex-direction:column; align-items:center;">
                        <div class="yz-hold-zone">
                            <div class="hold-slot" id="slot-0"></div>
                            <div class="hold-slot" id="slot-1"></div>
                            <div class="hold-slot" id="slot-2"></div>
                            <div class="hold-slot" id="slot-3"></div>
                            <div class="hold-slot" id="slot-4"></div>
                        </div>
                        <div class="yz-roll-zone" id="tray">
                            </div>
                    </div>
                `;
                
                // Sidebar: Scorecard
                this.els.side.innerHTML = `<div class="score-card" id="yz-card"></div>`;
                this.renderCard();

                // Controls
                this.els.ctrl.innerHTML = `<button class="btn" id="roll-btn" onclick="gameApp.activeGame.roll()">ROLL (3)</button>`;

                // Create Dice Elements
                this.diceEls = [];
                const tray = document.getElementById('tray');
                for(let i=0; i<5; i++) {
                    const d = document.createElement('div');
                    d.className = 'die';
                    d.id = `d${i}`;
                    d.innerHTML = this.getFaceHTML();
                    d.onclick = () => this.toggleDie(i);
                    // Random initial placement in tray
                    this.placeInTray(d);
                    tray.appendChild(d);
                    this.diceEls.push(d);
                }
                this.updateDiceVisuals();
            }

            getFaceHTML() {
                let h = '';
                for(let f=1;f<=6;f++) {
                    let pips = '';
                    const n = f;
                    // Generic pip generation
                    for(let k=0; k<n; k++) pips += '<div class="pip"></div>';
                    h += `<div class="die-face df${f}">${pips}</div>`;
                }
                return h;
            }

            placeInTray(el) {
                // Random position within tray bounds (approx)
                const x = Math.random() * 400 - 200;
                const y = Math.random() * 200 - 100;
                const r = Math.random() * 360;
                el.style.left = `calc(50% + ${x}px)`;
                el.style.top = `calc(50% + ${y}px)`;
                el.style.transform = `rotate(${r}deg)`;
            }

            toggleDie(i) {
                if(this.rolls === 3) return; // Must roll first
                if(this.ai && this.turn === 2) return;

                this.held[i] = !this.held[i];
                this.updateDiceVisuals(i);
            }

            updateDiceVisuals(specificIndex = null) {
                const indexes = specificIndex !== null ? [specificIndex] : [0,1,2,3,4];
                const rotMap = {1:[0,0], 2:[-90,0], 3:[0,-90], 4:[0,90], 5:[90,0], 6:[180,0]};

                indexes.forEach(i => {
                    const el = this.diceEls[i];
                    const val = this.dice[i];
                    const r = rotMap[val];

                    if(this.held[i]) {
                        // Move to slot
                        const slot = document.getElementById(`slot-${i}`);
                        const rect = slot.getBoundingClientRect();
                        const trayRect = document.getElementById('tray').getBoundingClientRect();
                        
                        // Calculate relative position to tray (since dice are absolute in tray/board context)
                        // Actually, easier to appendChild to slot? No, changing parent breaks transition.
                        // We will use fixed positioning relative to tray center.
                        // Better approach for v10: Reparenting for solidity.
                        
                        el.style.position = 'relative';
                        el.style.left = '0'; el.style.top = '0'; el.style.transform = `rotateX(${r[0]}deg) rotateY(${r[1]}deg)`;
                        slot.appendChild(el);
                    } else {
                        // Move to tray
                        if(el.parentElement.id !== 'tray') {
                            el.style.position = 'absolute';
                            document.getElementById('tray').appendChild(el);
                            this.placeInTray(el); // Random scatter
                        }
                        // Apply rotation
                        el.style.transform = `${el.style.transform.split('rotateX')[0]} rotateX(${r[0]}deg) rotateY(${r[1]}deg)`;
                    }
                });
            }

            roll() {
                if(this.rolls <= 0) return;
                this.rolls--;
                document.getElementById('roll-btn').innerText = `ROLL (${this.rolls})`;
                if(this.rolls===0) document.getElementById('roll-btn').disabled = true;

                // Animate
                this.dice.forEach((v, i) => {
                    if(!this.held[i]) {
                        const el = this.diceEls[i];
                        el.classList.add('rolling');
                        // Random tumble pos
                        const x = Math.random() * 400 - 200;
                        const y = Math.random() * 200 - 100;
                        el.style.left = `calc(50% + ${x}px)`;
                        el.style.top = `calc(50% + ${y}px)`;
                        
                        // Logic
                        this.dice[i] = Math.ceil(Math.random()*6);
                    }
                });

                setTimeout(() => {
                    this.diceEls.forEach(el => el.classList.remove('rolling'));
                    this.updateDiceVisuals(); // Snap to faces
                    this.renderCard(); // Update possible scores
                    this.updateStatus();
                    
                    if(this.ai && this.turn === 2) {
                        setTimeout(() => this.aiTurn(), 1000);
                    }
                }, 600);
            }

            renderCard() {
                const c = document.getElementById('yz-card');
                let h = `<div class="sc-header"><div class="sc-col wide">Category</div><div class="sc-col">P1</div><div class="sc-col">${this.ai?'AI':'P2'}</div></div>`;
                
                // Calculate Upper Totals
                const getSum = (p) => {
                    let s = 0;
                    for(let k=0; k<6; k++) s += (this.scores[p][k] || 0);
                    return s;
                };
                const p1Sub = getSum(1); const p2Sub = getSum(2);
                const p1Bon = p1Sub >= 63 ? 35 : 0; const p2Bon = p2Sub >= 63 ? 35 : 0;

                const potentials = this.getPotentialScores(); // For current turn preview

                this.cats.forEach((cat, i) => {
                    const s1 = this.scores[1][i];
                    const s2 = this.scores[2][i];
                    
                    // Interaction Logic
                    let p1Txt = s1 !== undefined ? s1 : '';
                    let p2Txt = s2 !== undefined ? s2 : '';
                    
                    // Preview
                    if(this.rolls < 3) {
                        if(this.turn===1 && s1===undefined) p1Txt = `<span style="color:blue">${potentials[i]}</span>`;
                        if(this.turn===2 && s2===undefined && !this.ai) p2Txt = `<span style="color:blue">${potentials[i]}</span>`;
                    }

                    const active = (this.turn===1 && s1===undefined) || (this.turn===2 && !this.ai && s2===undefined);
                    const click = active && this.rolls<3 ? `onclick="gameApp.activeGame.score(${i})"` : '';

                    h += `<div class="sc-row ${!click?'locked':''}" ${click}>
                        <div class="sc-cat">${cat}</div>
                        <div class="sc-val">${p1Txt}</div>
                        <div class="sc-val">${p2Txt}</div>
                    </div>`;
                });

                // Render Totals
                const total = p => {
                    let t = getSum(p) + (p===1?p1Bon:p2Bon);
                    for(let k=6; k<13; k++) t += (this.scores[p][k] || 0);
                    return t;
                };

                h += `<div class="sc-row" style="background:#ddd; font-weight:bold; margin-top:10px;">
                    <div class="sc-cat">TOTAL</div><div class="sc-val">${total(1)}</div><div class="sc-val">${total(2)}</div>
                </div>`;
                
                c.innerHTML = h;
            }

            getPotentialScores() {
                const counts = [0,0,0,0,0,0,0]; this.dice.forEach(x=>counts[x]++);
                const sum = this.dice.reduce((a,b)=>a+b,0);
                const res = [];
                
                // 0-5: Upper
                for(let i=1; i<=6; i++) res.push(counts[i]*i);
                
                // 6: 3oK
                res.push(counts.some(x=>x>=3) ? sum : 0);
                // 7: 4oK
                res.push(counts.some(x=>x>=4) ? sum : 0);
                // 8: Full House (Strict: 3 of one, 2 of another, or 5 of one)
                const has3 = counts.some(x=>x===3); const has2 = counts.some(x=>x===2);
                const has5 = counts.some(x=>x===5);
                res.push((has3&&has2)||has5 ? 25 : 0);
                // 9: Sm Str (4 in row)
                const str = this.longestSeq(counts);
                res.push(str>=4 ? 30 : 0);
                // 10: Lg Str (5 in row)
                res.push(str>=5 ? 40 : 0);
                // 11: Yahtzee
                res.push(has5 ? 50 : 0);
                // 12: Chance
                res.push(sum);
                
                return res;
            }

            longestSeq(c) {
                let m=0, cur=0;
                for(let i=1; i<=6; i++) { if(c[i]>0)cur++; else cur=0; m=Math.max(m,cur); }
                return m;
            }

            score(idx) {
                const pot = this.getPotentialScores();
                this.scores[this.turn][idx] = pot[idx];
                
                // Reset
                this.dice = [1,1,1,1,1];
                this.held = [false,false,false,false,false];
                this.rolls = 3;
                this.diceEls.forEach(el => {
                    document.getElementById('tray').appendChild(el); // Return all to tray
                    el.style.position = 'absolute';
                    this.placeInTray(el);
                });
                this.updateDiceVisuals();
                
                document.getElementById('roll-btn').disabled = false;
                document.getElementById('roll-btn').innerText = "ROLL (3)";

                // Game Over Check
                const p1Done = Object.keys(this.scores[1]).length === 13 && !Object.values(this.scores[1]).includes(undefined); // Wait, array init is null?
                // Actually array is initialized with undefined? No, map logic.
                // Let's count nulls.
                const countNull = (p) => Object.values(this.scores[p]).filter(x=>x===undefined).length; 
                // My init used 'null' but array access on missing key is undefined.
                // Re-check init: Array(13).fill(undefined) implicitly in logic? 
                // Ah, I used .fill(null) in constructor.
                
                const done1 = !this.scores[1].includes(undefined) && !this.scores[1].includes(null);
                const done2 = !this.scores[2].includes(undefined) && !this.scores[2].includes(null);

                if(done1 && done2) {
                    gameApp.setStatus("GAME OVER");
                    this.renderCard();
                    return;
                }

                this.turn = this.turn===1 ? 2 : 1;
                this.updateStatus();
                this.renderCard();

                if(this.ai && this.turn === 2) {
                    setTimeout(()=>this.roll(), 1000);
                }
            }

            updateStatus() {
                const p = this.turn===1 ? "Player 1" : (this.ai?"AI":"Player 2");
                gameApp.setStatus(this.rolls===3 ? `${p}'s Turn` : `${p} Rolling...`);
            }

            // Simple AI
            aiTurn() {
                if(this.rolls > 0) {
                    // Decide to hold
                    const counts = [0,0,0,0,0,0,0]; this.dice.forEach(x=>counts[x]++);
                    const max = Math.max(...counts);
                    const target = counts.lastIndexOf(max);
                    // Hold matches
                    for(let i=0; i<5; i++) {
                        if(this.dice[i] === target && max >= 2) this.held[i] = true;
                    }
                    this.updateDiceVisuals();
                    setTimeout(()=>this.roll(), 1000);
                } else {
                    // Pick best score
                    const pot = this.getPotentialScores();
                    let bestIdx = -1, maxScore = -1;
                    pot.forEach((s, i) => {
                        if(this.scores[2][i] === null && s > maxScore) {
                            maxScore = s; bestIdx = i;
                        }
                    });
                    // Fallback: pick first empty (0 points)
                    if(bestIdx === -1) bestIdx = this.scores[2].findIndex(x=>x===null);
                    
                    this.score(bestIdx);
                }
            }
        }

        /* --- CONNECT 4 --- */
        class Connect4 {
            constructor(b, s, c, ai) {
                this.b = b; this.ai = ai; this.turn=1; this.grid=[];
                this.board = Array(6).fill().map(()=>Array(7).fill(0));
                this.render(); gameApp.setStatus("Red's Turn");
            }
            render() {
                this.b.innerHTML = `<div class="c4-board" id="c4g"></div>`;
                const g = document.getElementById('c4g');
                for(let r=0; r<6; r++) {
                    for(let c=0; c<7; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'c4-slot';
                        cell.onclick = () => this.drop(c);
                        g.appendChild(cell);
                        this.grid.push(cell);
                    }
                }
            }
            drop(c) {
                if(this.over || (this.ai && this.turn===2)) return;
                let r = -1;
                for(let i=5; i>=0; i--) if(this.board[i][c]===0) { r=i; break; }
                if(r === -1) return;
                
                const p = this.turn===1 ? 'red' : 'yel';
                this.board[r][c] = this.turn;
                
                const piece = document.createElement('div');
                piece.className = `c4-piece ${p}`;
                this.grid[r*7+c].appendChild(piece);
                requestAnimationFrame(()=>piece.classList.add('dropped'));

                if(this.checkWin(r,c,this.turn)) {
                    gameApp.setStatus(p.toUpperCase() + " WINS!");
                    this.over = true;
                } else {
                    this.turn = this.turn===1?2:1;
                    gameApp.setStatus(this.turn===1?"Red's Turn":"Yellow's Turn");
                    if(this.ai && this.turn===2) setTimeout(()=>this.aiMove(), 600);
                }
            }
            checkWin(r,c,p) {
                const d=[[0,1],[1,0],[1,1],[1,-1]];
                return d.some(([dr,dc]) => {
                    let k=1;
                    for(let i=1;i<4;i++) if(this.board[r+dr*i]?.[c+dc*i]===p) k++; else break;
                    for(let i=1;i<4;i++) if(this.board[r-dr*i]?.[c-dc*i]===p) k++; else break;
                    return k>=4;
                });
            }
            aiMove() {
                let c; 
                // Try to win or block (Simple)
                for(let t=1; t<=2; t++) { // Check self(2) then opp(1)
                    for(let col=0; col<7; col++) {
                        let r = -1; for(let i=5; i>=0; i--) if(this.board[i][col]===0) { r=i; break; }
                        if(r!==-1) {
                            this.board[r][col] = t; // sim
                            if(this.checkWin(r,col,t)) { this.board[r][col]=0; c=col; break; }
                            this.board[r][col] = 0;
                        }
                    }
                    if(c !== undefined) break;
                }
                if(c === undefined) c = Math.floor(Math.random()*7);
                this.drop(c);
            }
        }

        /* --- CHESS (Simplified Visuals) --- */
        class Chess {
            constructor(b, s, c, ai) {
                this.el = b; this.ai = ai; this.turn=1; 
                this.board = [
                    ['r','n','b','q','k','b','n','r'],
                    ['p','p','p','p','p','p','p','p'],
                    ...Array(4).fill(0).map(()=>Array(8).fill(null)),
                    ['P','P','P','P','P','P','P','P'],
                    ['R','N','B','Q','K','B','N','R']
                ];
                this.render(); gameApp.setStatus("White's Turn");
            }
            render() {
                this.el.innerHTML = '<div class="chess-board" id="cb"></div>';
                const g = document.getElementById('cb');
                this.cells = [];
                for(let r=0; r<8; r++) {
                    for(let c=0; c<8; c++) {
                        const d = document.createElement('div');
                        d.className = `cell ${(r+c)%2?'dark':'light'}`;
                        d.onclick = () => this.clk(r,c);
                        g.appendChild(d);
                        this.cells.push(d);
                    }
                }
                this.draw();
            }
            draw() {
                const sym = {P:'â™Ÿ',R:'â™œ',N:'â™ž',B:'â™',Q:'â™›',K:'â™š',p:'â™Ÿ',r:'â™œ',n:'â™ž',b:'â™',q:'â™›',k:'â™š'};
                this.cells.forEach((d, i) => {
                    const r = Math.floor(i/8), c = i%8;
                    d.innerHTML = ''; d.classList.remove('highlight');
                    if(this.board[r][c]) {
                        const s = document.createElement('div');
                        s.className = `chess-p ${this.board[r][c]<'a'?'w':'b'}`;
                        s.innerText = sym[this.board[r][c]];
                        s.style.color = this.board[r][c]<'a'?'#fff':'#000';
                        d.appendChild(s);
                    }
                });
                if(this.sel) this.cells[this.sel.r*8+this.sel.c].style.background = '#ffeb3b';
            }
            clk(r,c) {
                if(this.ai && this.turn===2) return;
                const p = this.board[r][c];
                const own = p && (this.turn===1 ? p<'a' : p>'Z');
                
                if(own) { this.sel = {r,c}; this.draw(); } // Select
                else if(this.sel) {
                    // Move (No validation for brevity in v10, purely movement demo)
                    this.board[r][c] = this.board[this.sel.r][this.sel.c];
                    this.board[this.sel.r][this.sel.c] = null;
                    this.sel = null;
                    this.turn = this.turn===1?2:1;
                    this.draw();
                    gameApp.setStatus(this.turn===1?"White's Turn":"Black's Turn");
                    if(this.ai) setTimeout(()=>this.aiMove(), 500);
                }
            }
            aiMove() {
                // Random move
                let pcs = [];
                this.board.forEach((row,r)=>row.forEach((p,c)=>{ if(p && p>'Z') pcs.push({r,c}); }));
                if(!pcs.length) return;
                const f = pcs[Math.floor(Math.random()*pcs.length)];
                // Random dest (simplified)
                const dr = f.r + (Math.random()>0.5?1:-1);
                if(this.board[dr]?.[f.c] !== undefined) {
                    this.board[dr][f.c] = this.board[f.r][f.c];
                    this.board[f.r][f.c] = null;
                    this.turn = 1; this.draw(); gameApp.setStatus("White's Turn");
                } else this.aiMove(); // Retry
            }
        }

        /* --- CHECKERS --- */
        class Checkers {
            constructor(b, s, c, ai) {
                this.el=b; this.ai=ai; this.turn=1; 
                this.board = Array(8).fill().map(()=>Array(8).fill(null));
                for(let r=0;r<8;r++)for(let c=0;c<8;c++)if((r+c)%2){if(r<3)this.board[r][c]={p:2,k:0};if(r>4)this.board[r][c]={p:1,k:0};}
                this.render(); gameApp.setStatus("Red's Turn");
            }
            render() {
                this.el.innerHTML = '<div class="chk-board" id="chkb"></div>';
                const g = document.getElementById('chkb');
                this.cells = [];
                for(let r=0;r<8;r++)for(let c=0;c<8;c++){
                    const d = document.createElement('div'); d.className=`cell ${(r+c)%2?'dark':'light'}`;
                    d.onclick=()=>this.clk(r,c); g.appendChild(d); this.cells.push(d);
                }
                this.draw();
            }
            draw() {
                this.cells.forEach(d=>d.innerHTML='');
                for(let r=0;r<8;r++)for(let c=0;c<8;c++){
                    const p = this.board[r][c];
                    if(p) {
                        const d = document.createElement('div'); d.className=`chk-p ${p.p===1?'r':'b'} ${p.k?'king':''}`;
                        this.cells[r*8+c].appendChild(d);
                    }
                }
            }
            clk(r,c){
                if(this.ai&&this.turn===2)return;
                const p = this.board[r][c];
                if(p && p.p===this.turn) this.sel={r,c};
                else if(this.sel) {
                    // Move
                    if((r+c)%2===1 && !p) {
                        this.board[r][c] = this.board[this.sel.r][this.sel.c];
                        this.board[this.sel.r][this.sel.c] = null;
                        this.sel = null; this.turn = this.turn===1?2:1;
                        this.draw(); gameApp.setStatus(this.turn===1?"Red's Turn":"Black's Turn");
                        if(this.ai) setTimeout(()=>this.aiMove(),500);
                    }
                }
            }
            aiMove(){
                let mvs=[]; for(let r=0;r<8;r++)for(let c=0;c<8;c++)if(this.board[r][c]?.p===2) mvs.push({r,c});
                if(!mvs.length) return;
                const f = mvs[Math.floor(Math.random()*mvs.length)];
                const dr=f.r+1, dc=f.c+(Math.random()>0.5?1:-1);
                if(this.board[dr]?.[dc]===null) {
                    this.board[dr][dc]=this.board[f.r][f.c]; this.board[f.r][f.c]=null;
                    this.turn=1; this.draw(); gameApp.setStatus("Red's Turn");
                } else this.aiMove();
            }
        }

        class TTT {
            constructor(b,s,c,ai){this.el=b;this.ai=ai;this.t=1;this.b=Array(9).fill(null);this.render();gameApp.setStatus("X Turn");}
            render(){this.el.innerHTML='<div class="ttt-board"></div>';const g=this.el.querySelector('.ttt-board');for(let i=0;i<9;i++){const d=document.createElement('div');d.className='ttt-cell';d.onclick=()=>this.mv(i);g.appendChild(d);}}
            mv(i){if(this.b[i]||(this.ai&&this.t===2))return;const p=this.t===1?'X':'O';this.b[i]=p;this.el.querySelectorAll('.ttt-cell')[i].innerHTML=`<span class="${p.toLowerCase()}">${p}</span>`;
            if(this.chk(p)){gameApp.setStatus(p+" WINS!");this.t=0;}else{this.t=this.t===1?2:1;gameApp.setStatus(this.t===1?"X Turn":"O Turn");if(this.ai&&this.t===2)setTimeout(()=>this.aim(),500);}}
            aim(){let i=Math.floor(Math.random()*9);while(this.b[i])i=Math.floor(Math.random()*9);this.mv(i);}
            chk(p){return [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]].some(c=>this.b[c[0]]===p&&this.b[c[1]]===p&&this.b[c[2]]===p);}
        }

        // Initialize
        gameApp.init();

    </script>
</body>
</html>
